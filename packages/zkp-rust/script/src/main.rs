//! SP1 Proof Generation Script for Credential Verification
//!
//! This script generates zero-knowledge proofs for credential verification
//! that can be verified on-chain using the SP1 verifier.

use anyhow::Result;
use clap::Parser;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use sp1_sdk::{HashableKey, ProverClient, SP1Stdin};

/// The ELF binary of the credential verifier program
/// This is generated by building the program package
const ELF: &[u8] = include_bytes!("../../program/elf/riscv32im-succinct-zkvm-elf");

/// CLI arguments
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to the credential JSON file
    #[arg(short, long)]
    credential: String,

    /// Output path for the proof
    #[arg(short, long, default_value = "proof.json")]
    output: String,

    /// Whether to generate a PLONK proof (for on-chain verification)
    #[arg(long, default_value = "true")]
    plonk: bool,
}

/// Credential input data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CredentialInput {
    /// The subject's Ethereum address (20 bytes as hex string)
    pub subject: [u8; 20],
    /// The credential type
    pub credential_type: u32,
    /// Raw credential data
    pub credential_data: Vec<u8>,
    /// Issuer's signature
    pub signature: Vec<u8>,
    /// Issuer's public key
    pub issuer_pubkey: Vec<u8>,
    /// Issuance timestamp
    pub issued_at: u64,
    /// Expiration timestamp
    pub expires_at: u64,
    /// Current timestamp
    pub current_time: u64,
}

/// Proof output for serialization
#[derive(Debug, Serialize, Deserialize)]
pub struct ProofOutput {
    /// The proof bytes (hex encoded)
    pub proof: String,
    /// The public values (hex encoded)
    pub public_values: String,
    /// The program verification key (hex encoded)
    pub vkey: String,
    /// Subject address
    pub subject: String,
    /// Credential type
    pub credential_type: u32,
    /// Credential hash (hex encoded)
    pub credential_hash: String,
}

/// Creates a sample credential for testing
fn create_sample_credential(
    subject_hex: &str,
    credential_type: u32,
) -> Result<CredentialInput> {
    // Parse subject address
    let subject_bytes = hex::decode(subject_hex.trim_start_matches("0x"))?;
    let mut subject = [0u8; 20];
    subject.copy_from_slice(&subject_bytes);

    // Create sample credential data
    // Format: version (4 bytes) + claim_count (4 bytes) + claims
    let version: u32 = 1;
    let claim_count: u32 = match credential_type {
        1 => 1, // KYC
        2 => 2, // Accredited
        3 => 2, // Qualified
        4 => 3, // Institutional
        5 => 1, // AML
        _ => 1,
    };

    let mut credential_data = Vec::new();
    credential_data.extend_from_slice(&version.to_be_bytes());
    credential_data.extend_from_slice(&claim_count.to_be_bytes());

    // Add dummy claim data
    for i in 0..claim_count {
        credential_data.extend_from_slice(&[i as u8; 32]); // 32-byte claim
    }

    // Create sample signature (64 bytes)
    let signature = vec![0u8; 64];

    // Create sample public key (33 bytes compressed)
    let issuer_pubkey = vec![0x02; 33];

    // Timestamps
    let current_time = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)?
        .as_secs();
    let issued_at = current_time - 86400; // Issued 1 day ago
    let expires_at = current_time + 365 * 86400; // Expires in 1 year

    Ok(CredentialInput {
        subject,
        credential_type,
        credential_data,
        signature,
        issuer_pubkey,
        issued_at,
        expires_at,
        current_time,
    })
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    sp1_sdk::utils::setup_logger();

    let args = Args::parse();

    println!("SP1 Credential Verifier Proof Generator");
    println!("========================================");

    // Load or create credential
    let credential: CredentialInput = if args.credential == "sample" {
        println!("Creating sample credential...");
        create_sample_credential(
            "0x1234567890123456789012345678901234567890",
            2, // Accredited investor
        )?
    } else {
        println!("Loading credential from: {}", args.credential);
        let content = std::fs::read_to_string(&args.credential)?;
        serde_json::from_str(&content)?
    };

    println!("Subject: 0x{}", hex::encode(credential.subject));
    println!("Credential Type: {}", credential.credential_type);
    println!("Issued At: {}", credential.issued_at);
    println!("Expires At: {}", credential.expires_at);

    // Initialize the prover
    println!("\nInitializing SP1 prover...");
    let client = ProverClient::new();

    // Setup the program
    let (pk, vk) = client.setup(ELF);
    println!("Program VKey: 0x{}", hex::encode(vk.bytes32()));

    // Prepare inputs
    let mut stdin = SP1Stdin::new();
    stdin.write(&credential);

    println!("\nGenerating proof (this may take a while)...");

    // Generate the proof
    let proof = if args.plonk {
        println!("Generating PLONK proof for on-chain verification...");
        client.prove(&pk, stdin).plonk().run()?
    } else {
        println!("Generating core proof...");
        client.prove(&pk, stdin).run()?
    };

    println!("Proof generated successfully!");

    // Extract public values
    let public_values = proof.public_values.to_vec();
    println!("Public values length: {} bytes", public_values.len());

    // Compute credential hash for output
    let mut hasher = Sha256::new();
    hasher.update(&credential.subject);
    hasher.update(credential.credential_type.to_be_bytes());
    hasher.update(&credential.credential_data);
    hasher.update(&credential.issuer_pubkey);
    let credential_hash = hasher.finalize();

    // Create output
    let output = ProofOutput {
        proof: hex::encode(proof.bytes()),
        public_values: hex::encode(&public_values),
        vkey: hex::encode(vk.bytes32()),
        subject: format!("0x{}", hex::encode(credential.subject)),
        credential_type: credential.credential_type,
        credential_hash: format!("0x{}", hex::encode(credential_hash)),
    };

    // Save proof
    let output_json = serde_json::to_string_pretty(&output)?;
    std::fs::write(&args.output, &output_json)?;
    println!("\nProof saved to: {}", args.output);

    // Verify the proof locally
    println!("\nVerifying proof locally...");
    client.verify(&proof, &vk)?;
    println!("Local verification successful!");

    // Print summary
    println!("\n========================================");
    println!("Proof Generation Complete!");
    println!("========================================");
    println!("VKey: 0x{}", hex::encode(vk.bytes32()));
    println!("Subject: {}", output.subject);
    println!("Credential Type: {}", output.credential_type);
    println!("Credential Hash: {}", output.credential_hash);
    println!("\nTo verify on-chain, call SP1CredentialVerifier.verifyCredential()");
    println!("with the public values and proof bytes from {}", args.output);

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_sample_credential() {
        let credential = create_sample_credential(
            "0x1234567890123456789012345678901234567890",
            1,
        )
        .unwrap();

        assert_eq!(credential.credential_type, 1);
        assert!(!credential.credential_data.is_empty());
        assert_eq!(credential.signature.len(), 64);
        assert_eq!(credential.issuer_pubkey.len(), 33);
    }
}
